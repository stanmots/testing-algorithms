#include "GraphsOperationsHelper.h"


namespace graphsops {

bool isHamiltonianPath (const UndirectedGraphType& graph) {

    vertex_iter_t vertexItBegin, vertexItEnd, next;
    boost::tie(vertexItBegin, vertexItEnd) = vertices(graph);

    bool isHPathFound = true;
    const quint32 baseDegree = boost::out_degree(*vertexItBegin, graph);
    for (next = vertexItBegin; vertexItBegin != vertexItEnd; vertexItBegin = next) {
        ++next;

        const quint32 currentDegree = boost::out_degree(*vertexItBegin, graph);
        if(currentDegree != 0) {
            if(currentDegree != baseDegree) {
                isHPathFound = false;
                break;
            }
        }
    }

    return  isHPathFound;
}

void deleteVerticesWithoutEdges (UndirectedGraphType& graph) {

    vertex_iter_t vertexItBegin, vertexItEnd, next;
    boost::tie(vertexItBegin, vertexItEnd) = vertices(graph);

    for (next = vertexItBegin; vertexItBegin != vertexItEnd; vertexItBegin = next) {
        ++next;

        const quint32 currentDegree = boost::out_degree(*vertexItBegin, graph);
        if(currentDegree == 0) {
            remove_vertex(*vertexItBegin, graph);
        }
    }

}

void addHangingVerticesToCover (QList<int>& vertexCoverList, UndirectedGraphType& graph) {

    bool isNeedAnotherPass = true;
    vertex_iter_t vertexItBegin, vertexItEnd, next;
    adj_iter_t adjItBegin, adjItEnd;

    while (isNeedAnotherPass) {

        isNeedAnotherPass = false;

        boost::tie(vertexItBegin, vertexItEnd) = vertices(graph);

        for (next = vertexItBegin; vertexItBegin != vertexItEnd; vertexItBegin = next) {
            ++next;
            const quint32 vertexDegree = out_degree(*vertexItBegin, graph);

            switch(vertexDegree) {
            case NO_INCIDENT_EDGES:
                remove_vertex(*vertexItBegin, graph);
                break;
            case ONE_INCIDENT_EDGE:
                isNeedAnotherPass = true;
                tie(adjItBegin, adjItEnd) = adjacent_vertices(*vertexItBegin, graph);
                vertexCoverList.append(getIndexOfVertex(*adjItBegin, graph));
                clear_vertex(*adjItBegin, graph);
                remove_vertex(*vertexItBegin, graph);
                break;
            }
        }
    }
}

std::pair<quint32, quint32> getPairOfVerticesWithMaxDegree(const UndirectedGraphType& graph) {
    //[1] find the vertex with the most incident edges degree
    vertex_iter_t vertexItBegin, vertexItEnd, next;
    vertex_desc_t maxEdgesVertex;
    tie(vertexItBegin, vertexItEnd) = vertices(graph);
    quint32 maxDegree = 0;

    for (next = vertexItBegin; vertexItBegin != vertexItEnd; vertexItBegin = next) {
        ++next;

        const quint32 baseVertexDegree = out_degree(*vertexItBegin, graph);
        adj_iter_t adjVerItBegin, adjVerItEnd;

        tie(adjVerItBegin, adjVerItEnd) = boost::adjacent_vertices(*vertexItBegin, graph);
        for (; adjVerItBegin != adjVerItEnd; ++adjVerItBegin)  {
            const quint32 adjVertexDegree = out_degree(*adjVerItBegin, graph);
            quint32 commonDegree = adjVertexDegree + baseVertexDegree;
            if( commonDegree > maxDegree) {
                maxDegree = currentVertexDegree;
                maxEdgesVertex = *vertexItBegin;
            }

            const quint32 vi = getIndexOfVertex(*adjVerItBegin, graph);
        }
    }
}

}
